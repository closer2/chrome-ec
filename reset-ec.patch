diff --git a/board/pangul/board.c b/board/pangul/board.c
index 0642e4cba..515fbb0ec 100644
--- a/board/pangul/board.c
+++ b/board/pangul/board.c
@@ -439,16 +439,41 @@ void board_pwrbtn_to_pch(int level)
 
 static void board_chipset_resume(void)
 {
-	return;
+    ccprints("%s -> %s", __FILE__, __func__);
+    return;
 }
 DECLARE_HOOK(HOOK_CHIPSET_RESUME, board_chipset_resume, HOOK_PRIO_DEFAULT);
 
 static void board_chipset_suspend(void)
 {
-	return;
+    ccprints("%s -> %s", __FILE__, __func__);
+    return;
 }
 DECLARE_HOOK(HOOK_CHIPSET_SUSPEND, board_chipset_suspend, HOOK_PRIO_DEFAULT);
 
+static void board_chipset_shutdown(void)
+{
+    uint8_t *mptr = host_get_memmap(EC_MEMMAP_RESET_FLAG);
+
+    ccprints("EC_MEMMAP_RESET_FLAG = %X\n", *mptr);
+    if(0xAA == (*mptr))
+    {
+        (*mptr) = 0;
+        ccprints("EC reboot......");
+        system_reset(SYSTEM_RESET_MANUALLY_TRIGGERED);
+    }
+    ccprints("%s -> %s", __FILE__, __func__);
+    return;
+}
+DECLARE_HOOK(HOOK_CHIPSET_SHUTDOWN, board_chipset_shutdown, HOOK_PRIO_DEFAULT);
+
+static void board_chipset_startup(void)
+{
+    ccprints("%s -> %s", __FILE__, __func__);
+    return;
+}
+DECLARE_HOOK(HOOK_CHIPSET_STARTUP, board_chipset_startup, HOOK_PRIO_DEFAULT);
+
 /*****************************************************************************
  * USB-C
  */
diff --git a/chip/npcx/lpc.c b/chip/npcx/lpc.c
index f4b5b9338..a6e467241 100644
--- a/chip/npcx/lpc.c
+++ b/chip/npcx/lpc.c
@@ -443,26 +443,26 @@ void lpc_disable_acpi_interrupts(void)
  */
 static void handle_acpi_write(int is_cmd)
 {
-	uint8_t value, result;
+    uint8_t value, result;
 
-	/* Set processing flag before reading command byte */
-	SET_BIT(NPCX_HIPMST(PMC_ACPI), NPCX_HIPMST_F0);
+    /* Set processing flag before reading command byte */
+    SET_BIT(NPCX_HIPMST(PMC_ACPI), NPCX_HIPMST_F0);
 
-	/* Read command/data; this clears the FRMH status bit. */
-	value = NPCX_HIPMDI(PMC_ACPI);
+    /* Read command/data; this clears the FRMH status bit. */
+    value = NPCX_HIPMDI(PMC_ACPI);
 
-	/* Handle whatever this was. */
-	if (acpi_ap_to_ec(is_cmd, value, &result))
-		NPCX_HIPMDO(PMC_ACPI) = result;
+    /* Handle whatever this was. */
+    if (acpi_ap_to_ec(is_cmd, value, &result))
+        NPCX_HIPMDO(PMC_ACPI) = result;
 
-	/* Clear processing flag */
-	CLEAR_BIT(NPCX_HIPMST(PMC_ACPI), NPCX_HIPMST_F0);
+    /* Clear processing flag */
+    CLEAR_BIT(NPCX_HIPMST(PMC_ACPI), NPCX_HIPMST_F0);
 
-	/*
-	 * ACPI 5.0-12.6.1: Generate SCI for Input Buffer Empty / Output Buffer
-	 * Full condition on the kernel channel.
-	 */
-	lpc_generate_sci();
+    /*
+     * ACPI 5.0-12.6.1: Generate SCI for Input Buffer Empty / Output Buffer
+     * Full condition on the kernel channel.
+     */
+    lpc_generate_sci();
 }
 
 /**
@@ -558,13 +558,13 @@ DECLARE_IRQ(NPCX_IRQ_KBC_OBE, lpc_kbc_obe_interrupt, 4);
 /* PM channel input buffer full ISR */
 void lpc_pmc_ibf_interrupt(void)
 {
-	/* Channel-1 for ACPI usage*/
-	/* Channel-2 for Host Command usage , so the argument data had been
-	 * put on the share memory firstly*/
-	if (NPCX_HIPMST(PMC_ACPI) & 0x02)
-		handle_acpi_write((NPCX_HIPMST(PMC_ACPI)&0x08) ? 1 : 0);
-	else if (NPCX_HIPMST(PMC_HOST_CMD) & 0x02)
-		handle_host_write((NPCX_HIPMST(PMC_HOST_CMD)&0x08) ? 1 : 0);
+    /* Channel-1 for ACPI usage*/
+    /* Channel-2 for Host Command usage , so the argument data had been
+     * put on the share memory firstly*/
+    if (NPCX_HIPMST(PMC_ACPI) & 0x02)
+        handle_acpi_write((NPCX_HIPMST(PMC_ACPI)&0x08) ? 1 : 0);
+    else if (NPCX_HIPMST(PMC_HOST_CMD) & 0x02)
+        handle_host_write((NPCX_HIPMST(PMC_HOST_CMD)&0x08) ? 1 : 0);
 }
 DECLARE_IRQ(NPCX_IRQ_PM_CHAN_IBF, lpc_pmc_ibf_interrupt, 4);
 
@@ -794,7 +794,7 @@ static void lpc_init(void)
 	NPCX_WIN_BASE(0) = (uint32_t)shm_mem_host_cmd;
 	NPCX_WIN_BASE(1) = (uint32_t)shm_memmap;
 	/* Write protect of Share memory */
-	NPCX_WIN_WR_PROT(1) = 0xFF;
+	//NPCX_WIN_WR_PROT(1) = 0xFF;
     
 	/* We support LPC args and version 3 protocol */
 	*(lpc_get_memmap_range() + EC_MEMMAP_HOST_CMD_FLAGS) =
diff --git a/common/acpi.c b/common/acpi.c
index 92117f09b..4566a0b0f 100644
--- a/common/acpi.c
+++ b/common/acpi.c
@@ -34,22 +34,6 @@ static int __bss_slow acpi_data_count;
 /* Test byte in ACPI memory space */
 static uint8_t __bss_slow acpi_mem_test;
 
-#ifdef CONFIG_DPTF
-static int __bss_slow dptf_temp_sensor_id;	/* last sensor ID written */
-static int __bss_slow dptf_temp_threshold;	/* last threshold written */
-
-/*
- * Current DPTF profile number.
- * This is by default initialized to 1 if multi-profile DPTF is not supported.
- * If multi-profile DPTF is supported, this is by default initialized to 2 under
- * the assumption that profile #2 corresponds to lower thresholds and is a safer
- * profile to use until board or some EC driver sets the appropriate profile for
- * device mode.
- */
-static int current_dptf_profile = DPTF_PROFILE_DEFAULT;
-
-#endif
-
 /*
  * Keep a read cache of four bytes when burst mode is enabled, which is the
  * size of the largest non-string memmap data type.
@@ -82,81 +66,59 @@ static struct {
  */
 static void acpi_disable_burst_deferred(void)
 {
-	acpi_read_cache.enabled = 0;
-	lpc_clear_acpi_status_mask(EC_LPC_STATUS_BURST_MODE);
-	CPUTS("ACPI missed burst disable?");
+    acpi_read_cache.enabled = 0;
+    lpc_clear_acpi_status_mask(EC_LPC_STATUS_BURST_MODE);
+    CPUTS("ACPI missed burst disable?");
 }
 DECLARE_DEFERRED(acpi_disable_burst_deferred);
 
-#ifdef CONFIG_DPTF
-
-static int acpi_dptf_is_profile_valid(int n)
-{
-#ifdef CONFIG_DPTF_MULTI_PROFILE
-	if ((n < DPTF_PROFILE_VALID_FIRST) || (n > DPTF_PROFILE_VALID_LAST))
-		return EC_ERROR_INVAL;
-#else
-	if (n != DPTF_PROFILE_DEFAULT)
-		return EC_ERROR_INVAL;
-#endif
-
-	return EC_SUCCESS;
-}
-
-int acpi_dptf_set_profile_num(int n)
-{
-	int ret = acpi_dptf_is_profile_valid(n);
-
-	if (ret == EC_SUCCESS) {
-		current_dptf_profile = n;
-		if (IS_ENABLED(CONFIG_DPTF_MULTI_PROFILE) &&
-		    IS_ENABLED(CONFIG_HOSTCMD_EVENTS)) {
-			/* Notify kernel to update DPTF profile */
-			host_set_single_event(EC_HOST_EVENT_MODE_CHANGE);
-		}
-	}
-	return ret;
-}
-
-int acpi_dptf_get_profile_num(void)
-{
-	return current_dptf_profile;
-}
-
-#endif
-
 /* Read memmapped data, returns read data or 0xff on error. */
 static int acpi_read(uint8_t addr)
 {
-	uint8_t *memmap_addr = (uint8_t *)(lpc_get_memmap_range() + addr -
-					   EC_ACPI_MEM_MAPPED_BEGIN);
-
-	/* Check for out-of-range read. */
-	if (addr < EC_ACPI_MEM_MAPPED_BEGIN ||
-	    addr >= EC_ACPI_MEM_MAPPED_BEGIN + EC_ACPI_MEM_MAPPED_SIZE) {
-		CPRINTS("ACPI read 0x%02x (ignored)",
-			acpi_addr);
-		return 0xff;
-	}
+    uint8_t *memmap_addr = (uint8_t *)(lpc_get_memmap_range() + addr -
+                            EC_ACPI_MEM_MAPPED_BEGIN);
+
+    /* Check for out-of-range read. */
+    if (addr < EC_ACPI_MEM_MAPPED_BEGIN ||
+        addr >= EC_ACPI_MEM_MAPPED_BEGIN + EC_ACPI_MEM_MAPPED_SIZE) {
+        /*CPRINTS("ACPI read 0x%02x (ignored)", acpi_addr);*/
+        return 0xff;
+    }
+
+    /* Read from cache if enabled (burst mode). */
+    if (acpi_read_cache.enabled) {
+        /* Fetch to cache on miss. */
+        if (acpi_read_cache.start_addr == ACPI_READ_CACHE_FLUSHED ||
+            acpi_read_cache.start_addr > addr ||
+            addr - acpi_read_cache.start_addr >=
+            ACPI_READ_CACHE_SIZE) {
+            memcpy(acpi_read_cache.data,
+            memmap_addr,
+            ACPI_VALID_CACHE_SIZE(addr));
+            acpi_read_cache.start_addr = addr;
+        }
+        /* Return data from cache. */
+        return acpi_read_cache.data[addr - acpi_read_cache.start_addr];
+    } else {
+        /* Read directly from memmap data. */
+        return *memmap_addr;
+    }
+}
 
-	/* Read from cache if enabled (burst mode). */
-	if (acpi_read_cache.enabled) {
-		/* Fetch to cache on miss. */
-		if (acpi_read_cache.start_addr == ACPI_READ_CACHE_FLUSHED ||
-		    acpi_read_cache.start_addr > addr ||
-		    addr - acpi_read_cache.start_addr >=
-		    ACPI_READ_CACHE_SIZE) {
-			memcpy(acpi_read_cache.data,
-			       memmap_addr,
-			       ACPI_VALID_CACHE_SIZE(addr));
-			acpi_read_cache.start_addr = addr;
-		}
-		/* Return data from cache. */
-		return acpi_read_cache.data[addr - acpi_read_cache.start_addr];
-	} else {
-		/* Read directly from memmap data. */
-		return *memmap_addr;
-	}
+static void acpi_write(uint8_t addr, int data)
+{
+    uint8_t *memmap_addr = (uint8_t *)(lpc_get_memmap_range() + addr -
+                            EC_ACPI_MEM_MAPPED_BEGIN);
+
+    /* Check for out-of-range write. */
+    if (addr < EC_ACPI_MEM_MAPPED_BEGIN ||
+        addr >= EC_ACPI_MEM_MAPPED_BEGIN + EC_ACPI_MEM_MAPPED_SIZE) {
+        CPRINTS("ACPI write 0x%02x->[0x%02x] (ignored)", data, acpi_addr);
+        return;
+    }
+
+    *memmap_addr = data;
+    CPRINTS("ACPI write 0x%02x->[0x%02x] (sucessfully)", data, acpi_addr);
 }
 
 /*
@@ -165,259 +127,109 @@ static int acpi_read(uint8_t addr)
  */
 int acpi_ap_to_ec(int is_cmd, uint8_t value, uint8_t *resultptr)
 {
-	int data = 0;
-	int retval = 0;
-	int result = 0xff;			/* value for bogus read */
-
-	/* Read command/data; this clears the FRMH status bit. */
-	if (is_cmd) {
-		acpi_cmd = value;
-		acpi_data_count = 0;
-	} else {
-		data = value;
-		/*
-		 * The first data byte is the ACPI memory address for
-		 * read/write commands.
-		 */
-		if (!acpi_data_count++)
-			acpi_addr = data;
-	}
+    int data = 0;
+    int retval = 0;
+    int result = 0xff;      /* value for bogus read */
+
+    /* Read command/data; this clears the FRMH status bit. */
+    if (is_cmd) {
+        acpi_cmd = value;
+        acpi_data_count = 0;
+    } else {
+        data = value;
+        /*
+        * The first data byte is the ACPI memory address for
+        * read/write commands.
+        */
+        if (!acpi_data_count++)
+            acpi_addr = data;
+    }
+
+    /* Process complete commands */
+    if (acpi_cmd == EC_CMD_ACPI_READ && acpi_data_count == 1) {
+    /* ACPI read cmd + addr */
+    switch (acpi_addr) {
+        case EC_ACPI_MEM_VERSION:
+            result = EC_ACPI_MEM_VERSION_CURRENT;
+            break;
+        case EC_ACPI_MEM_TEST:
+            result = acpi_mem_test;
+            break;
+        case EC_ACPI_MEM_TEST_COMPLIMENT:
+            result = 0xff - acpi_mem_test;
+            break;
 
-	/* Process complete commands */
-	if (acpi_cmd == EC_CMD_ACPI_READ && acpi_data_count == 1) {
-		/* ACPI read cmd + addr */
-		switch (acpi_addr) {
-		case EC_ACPI_MEM_VERSION:
-			result = EC_ACPI_MEM_VERSION_CURRENT;
-			break;
-		case EC_ACPI_MEM_TEST:
-			result = acpi_mem_test;
-			break;
-		case EC_ACPI_MEM_TEST_COMPLIMENT:
-			result = 0xff - acpi_mem_test;
-			break;
-#ifdef CONFIG_KEYBOARD_BACKLIGHT
-		case EC_ACPI_MEM_KEYBOARD_BACKLIGHT:
-			result = kblight_get();
-			break;
-#endif
 #ifdef CONFIG_FANS
-		case EC_ACPI_MEM_FAN_DUTY:
-			result = dptf_get_fan_duty_target();
-			break;
-#endif
-#ifdef CONFIG_DPTF
-		case EC_ACPI_MEM_TEMP_ID:
-			result = dptf_query_next_sensor_event();
-			break;
-#endif
-#ifdef CONFIG_CHARGER
-		case EC_ACPI_MEM_CHARGING_LIMIT:
-			result = dptf_get_charging_current_limit();
-			if (result >= 0)
-				result /= EC_ACPI_MEM_CHARGING_LIMIT_STEP_MA;
-			else
-				result = EC_ACPI_MEM_CHARGING_LIMIT_DISABLED;
-			break;
-#endif
-
-		case EC_ACPI_MEM_DEVICE_ORIENTATION:
-			result = 0;
+        case EC_ACPI_MEM_FAN_DUTY:
+            result = dptf_get_fan_duty_target();
+            break;
+#endif
+        default:
+            result = acpi_read(acpi_addr);
+            break;
+        }
+
+        /* Send the result byte */
+        *resultptr = result;
+        retval = 1;
+
+    } 
+    else if (acpi_cmd == EC_CMD_ACPI_WRITE && acpi_data_count == 2) {
+    /* ACPI write cmd + addr + data */
+    switch (acpi_addr) {
+        case EC_ACPI_MEM_TEST:
+            acpi_mem_test = data;
+            break;
 
-#ifdef CONFIG_TABLET_MODE
-			result = tablet_get_mode() << EC_ACPI_MEM_TBMD_SHIFT;
-#endif
-
-#ifdef CONFIG_DPTF
-			result |= (acpi_dptf_get_profile_num() &
-				   EC_ACPI_MEM_DDPN_MASK)
-				<< EC_ACPI_MEM_DDPN_SHIFT;
-#endif
-			break;
-
-		case EC_ACPI_MEM_DEVICE_FEATURES0:
-		case EC_ACPI_MEM_DEVICE_FEATURES1:
-		case EC_ACPI_MEM_DEVICE_FEATURES2:
-		case EC_ACPI_MEM_DEVICE_FEATURES3: {
-			int off = acpi_addr - EC_ACPI_MEM_DEVICE_FEATURES0;
-			uint32_t val = get_feature_flags0();
-
-			/* Flush EC_FEATURE_LIMITED bit. Having it reset to 0
-			 * means that FEATURES[0-3] are supported in the first
-			 * place, and the other bits are valid.
-			 */
-			val &= ~1;
-
-			result = val >> (8 * off);
-			break;
-			}
-		case EC_ACPI_MEM_DEVICE_FEATURES4:
-		case EC_ACPI_MEM_DEVICE_FEATURES5:
-		case EC_ACPI_MEM_DEVICE_FEATURES6:
-		case EC_ACPI_MEM_DEVICE_FEATURES7: {
-			int off = acpi_addr - EC_ACPI_MEM_DEVICE_FEATURES4;
-			uint32_t val = get_feature_flags1();
-
-			result = val >> (8 * off);
-			break;
-			}
-
-#ifdef CONFIG_USB_PORT_POWER_DUMB
-		case EC_ACPI_MEM_USB_PORT_POWER: {
-			int i;
-			const int port_count = MIN(8, USB_PORT_COUNT);
-
-			/*
-			 * Convert each USB port power GPIO signal to a bit
-			 * field with max size 8 bits. USB port ID (index) 0 is
-			 * the least significant bit.
-			 */
-			result = 0;
-			for (i = 0; i < port_count; ++i) {
-				if (gpio_get_level(usb_port_enable[i]) != 0)
-					result |= 1 << i;
-			}
-			break;
-			}
-#endif
-
-		default:
-			result = acpi_read(acpi_addr);
-			break;
-		}
-
-		/* Send the result byte */
-		*resultptr = result;
-		retval = 1;
-
-	} else if (acpi_cmd == EC_CMD_ACPI_WRITE && acpi_data_count == 2) {
-		/* ACPI write cmd + addr + data */
-		switch (acpi_addr) {
-		case EC_ACPI_MEM_TEST:
-			acpi_mem_test = data;
-			break;
-#ifdef CONFIG_BATTERY_V2
-		case EC_ACPI_MEM_BATTERY_INDEX:
-			CPRINTS("ACPI battery %d", data);
-			battery_memmap_set_index(data);
-			break;
-#endif
-#ifdef CONFIG_KEYBOARD_BACKLIGHT
-		case EC_ACPI_MEM_KEYBOARD_BACKLIGHT:
-			/*
-			 * Debug output with CR not newline, because the host
-			 * does a lot of keyboard backlights and it scrolls the
-			 * debug console.
-			 */
-			CPRINTF("\r[%pT ACPI kblight %d]",
-				PRINTF_TIMESTAMP_NOW, data);
-			kblight_set(data);
-			kblight_enable(data > 0);
-			break;
-#endif
 #ifdef CONFIG_FANS
-		case EC_ACPI_MEM_FAN_DUTY:
-			dptf_set_fan_duty_target(data);
-			break;
-#endif
-#ifdef CONFIG_DPTF
-		case EC_ACPI_MEM_TEMP_ID:
-			dptf_temp_sensor_id = data;
-			break;
-		case EC_ACPI_MEM_TEMP_THRESHOLD:
-			dptf_temp_threshold = data + EC_TEMP_SENSOR_OFFSET;
-			break;
-		case EC_ACPI_MEM_TEMP_COMMIT:
-		{
-			int idx = data & EC_ACPI_MEM_TEMP_COMMIT_SELECT_MASK;
-			int enable = data & EC_ACPI_MEM_TEMP_COMMIT_ENABLE_MASK;
-			dptf_set_temp_threshold(dptf_temp_sensor_id,
-						dptf_temp_threshold,
-						idx, enable);
-			break;
-		}
-#endif
-#ifdef CONFIG_CHARGER
-		case EC_ACPI_MEM_CHARGING_LIMIT:
-			if (data == EC_ACPI_MEM_CHARGING_LIMIT_DISABLED) {
-				dptf_set_charging_current_limit(-1);
-			} else {
-				data *= EC_ACPI_MEM_CHARGING_LIMIT_STEP_MA;
-				dptf_set_charging_current_limit(data);
-			}
-			break;
-#endif
-
-#ifdef CONFIG_USB_PORT_POWER_DUMB
-		case EC_ACPI_MEM_USB_PORT_POWER: {
-			int i;
-			int mode_field = data;
-			const int port_count = MIN(8, USB_PORT_COUNT);
-
-			/*
-			 * Read the port power bit field (with max size 8 bits)
-			 * and set the charge mode of each USB port accordingly.
-			 * USB port ID 0 is the least significant bit.
-			 */
-			for (i = 0; i < port_count; ++i) {
-				int mode = USB_CHARGE_MODE_DISABLED;
-
-				if (mode_field & 1)
-					mode = USB_CHARGE_MODE_ENABLED;
-
-				if (usb_charge_set_mode(i, mode,
-				    USB_ALLOW_SUSPEND_CHARGE)) {
-					CPRINTS("ERROR: could not set charge "
-						"mode of USB port p%d to %d",
-						i, mode);
-				}
-				mode_field >>= 1;
-			}
-			break;
-			}
-#endif
-
-		default:
-			CPRINTS("ACPI write 0x%02x = 0x%02x (ignored)",
-				acpi_addr, data);
-			break;
-		}
-	} else if (acpi_cmd == EC_CMD_ACPI_QUERY_EVENT && !acpi_data_count) {
-		/* Clear and return the lowest host event */
-		int evt_index = lpc_get_next_host_event();
-		CPRINTS("ACPI query = %d", evt_index);
-		*resultptr = evt_index;
-		retval = 1;
-	} else if (acpi_cmd == EC_CMD_ACPI_BURST_ENABLE && !acpi_data_count) {
-		/*
-		 * TODO: The kernel only enables BURST when doing multi-byte
-		 * value reads over the ACPI port. We don't do such reads
-		 * when our memmap data can be accessed directly over LPC,
-		 * so on LM4, for example, this is dead code. We might want
-		 * to add a config to skip this code for certain chips.
-		 */
-		acpi_read_cache.enabled = 1;
-		acpi_read_cache.start_addr = ACPI_READ_CACHE_FLUSHED;
-
-		/* Enter burst mode */
-		lpc_set_acpi_status_mask(EC_LPC_STATUS_BURST_MODE);
-
-		/*
-		 * Disable from deferred function in case burst mode is enabled
-		 * for an extremely long time  (ex. kernel bug / crash).
-		 */
-		hook_call_deferred(&acpi_disable_burst_deferred_data, 1*SECOND);
-
-		/* ACPI 5.0-12.3.3: Burst ACK */
-		*resultptr = 0x90;
-		retval = 1;
-	} else if (acpi_cmd == EC_CMD_ACPI_BURST_DISABLE && !acpi_data_count) {
-		acpi_read_cache.enabled = 0;
-
-		/* Leave burst mode */
-		hook_call_deferred(&acpi_disable_burst_deferred_data, -1);
-		lpc_clear_acpi_status_mask(EC_LPC_STATUS_BURST_MODE);
-	}
-
-	return retval;
+        case EC_ACPI_MEM_FAN_DUTY:
+            dptf_set_fan_duty_target(data);
+            break;
+#endif
+
+        default:
+            acpi_write(acpi_addr, data);
+            break;
+        }
+    }
+    else if (acpi_cmd == EC_CMD_ACPI_QUERY_EVENT && !acpi_data_count) {
+        /* Clear and return the lowest host event */
+        int evt_index = lpc_get_next_host_event();
+        CPRINTS("ACPI query = %d", evt_index);
+        *resultptr = evt_index;
+        retval = 1;
+    }
+    else if (acpi_cmd == EC_CMD_ACPI_BURST_ENABLE && !acpi_data_count) {
+        /*
+         * TODO: The kernel only enables BURST when doing multi-byte
+         * value reads over the ACPI port. We don't do such reads
+         * when our memmap data can be accessed directly over LPC,
+         * so on LM4, for example, this is dead code. We might want
+         * to add a config to skip this code for certain chips.
+         */
+        acpi_read_cache.enabled = 1;
+        acpi_read_cache.start_addr = ACPI_READ_CACHE_FLUSHED;
+
+        /* Enter burst mode */
+        lpc_set_acpi_status_mask(EC_LPC_STATUS_BURST_MODE);
+
+        /*
+         * Disable from deferred function in case burst mode is enabled
+         * for an extremely long time  (ex. kernel bug / crash).
+         */
+        hook_call_deferred(&acpi_disable_burst_deferred_data, 1*SECOND);
+
+        /* ACPI 5.0-12.3.3: Burst ACK */
+        *resultptr = 0x90;
+        retval = 1;
+    }
+    else if (acpi_cmd == EC_CMD_ACPI_BURST_DISABLE && !acpi_data_count) {
+        acpi_read_cache.enabled = 0;
+
+        /* Leave burst mode */
+        hook_call_deferred(&acpi_disable_burst_deferred_data, -1);
+        lpc_clear_acpi_status_mask(EC_LPC_STATUS_BURST_MODE);
+    }
+
+    return retval;
 }
diff --git a/include/ec_commands.h b/include/ec_commands.h
index 1d232db9a..92276dc60 100644
--- a/include/ec_commands.h
+++ b/include/ec_commands.h
@@ -134,7 +134,7 @@ extern "C" {
 #define EC_MEMMAP_VERSION_X                 0x00 /* EC_VERSION_X */
 #define EC_MEMMAP_VERSION_YZ                0x01 /* EC_VERSION_YZ */
 #define EC_MEMMAP_VERSION_TEST              0x02 /* EC_VERSION_TEST */
-/* Unused 0x03 */
+#define EC_MEMMAP_RESET_FLAG                0x03 /* =0xAA, EC reset after system shutdown*/
 #define EC_MEMMAP_Year                      0x04 /* EC_Year */
 #define EC_MEMMAP_Month                     0x05 /* EC_Month */
 #define EC_MEMMAP_Day                       0x06 /* EC_Day */
